<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Ryo's blog</title><meta name="description" content="行万里路，读万卷书"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?" + '2c076421eb9f21a0a143f8ee9c4ab171';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><meta name="referrer" content="no-referrer"><link rel="icon" href="/null"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/widget-post-list.css"><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Ryo's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><span>标签 · Middleware</span></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><article class="post-container is-flex is-justify-content-center section container is-max-widescreen pt-4 px-2"><div class="columns is-variable is-1-tablet is-3-desktop-only is-2-widescreen is-full-width"><section class="column"><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2021/02/11/mysql-insert-lock/">MySQL Insert 死锁问题研究</a></h2><time class="has-text-grey" datetime="2021-02-10T17:36:27.000Z">2021-02-11</time><p class="is-flex-grow-2 mt-2">背景不想看废话的，建议直接去最后看死锁的本质原因。
问题背景线上一个很简单结构的表，报insert死锁，这个表基本上只有insert操作，所以引出一个问题insert 和insert之间为什么会死锁？
顺便说下我们线上库的隔离级别都是RC，日志格式是ROW，我下面所有测试都是在RC下。
*** (1) TRANSACTION:
TRANSACTION 2404187192, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 8 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 118913019, OS thread handle 140411115681..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2021/02/11/mysql-insert-lock/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/05/25/mysql-insert-auto-incre/">MySQL 自增列 Duplicate Error 问题分析</a></h2><time class="has-text-grey" datetime="2022-05-25T04:30:56.000Z">2022-05-25</time><p class="is-flex-grow-2 mt-2">一、背景最近我们在做线上的数据迁移测试（可以理解就是把A数据中心的数据迁移到B数据中心，A和B数据中心的MySQL是同构的，迁移过程中，A、B的MySQL都有正常的业务数据写入，具体背景可以看 数据传输系统落地和思考 这篇文章）。每次我们触发迁移的时候，就有业务方反馈他们写入数据的时候就会有Error 1062: Duplicate entry 'xxx' for key 'PRIMARY'这样的错误。业务方同学还反馈他们写数据的时候并没有指定ID，所以他们对这样的报错比较困惑，具体他们的数据写入的伪代码如下：
type Data struct {
    ID           int64     `gorm:&quot;primaryKey;column:id&quot;`
    PageID       string..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/05/25/mysql-insert-auto-incre/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://upload-images.jianshu.io/upload_images/12321605-5a4f15ef8cd7c7b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2021/11/28/mysql-time/"><img class="post-cover-img js-img-fadeIn" src="https://upload-images.jianshu.io/upload_images/12321605-5a4f15ef8cd7c7b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2021/11/28/mysql-time/">MySQL DateTime和Timestamp时区问题</a></h2><time class="has-text-grey" datetime="2021-11-27T17:00:00.000Z">2021-11-28</time><p class="is-flex-grow-2 mt-2">


一、背景最近负责一个数据传输的项目，其中一个需求就是能把一个DB里面的数据拉出来 ，然后回放到另外一个同构的DB。两个DB的服务不在一个时区（其实这不是重点），可能配置不同。之前有过类似的项目，当时是基建的同事负责做数据同步，同步过去以后DateTime、Timestamp字段的时区信息都丢了。老板让我调研下问题根因，不要踩之前的坑。
最早的时候看了下同事写的当时MySQL时区信息丢失的问题总结文档，文档里面当时把DateTime和Timestamp两个时区问题混为一起了，也没分析本质原因，导致我当时没看太明白，然后的武断的认为，之所以时区丢失了，是因为基础组件同步DateTime和Timestamp的时候同步的是字符串，比如2021-11-27 10:49:35.857969这种信息，我们传输的时候..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2021/11/28/mysql-time/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Envoy"><i class="tag post-item-tag">Envoy</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2021/07/16/envoy-debug/">Envoy 编译调试</a></h2><time class="has-text-grey" datetime="2021-07-16T12:09:00.000Z">2021-07-16</time><p class="is-flex-grow-2 mt-2">Debian9 上编译调试主要参考Envoy官方的Bazel编译文档

下载bazelisk-linux-amd64
 sudo wget -O /usr/local/bin/bazel https://github.com/bazelbuild/bazelisk/releases/latest/download/bazelisk-linux-amd64
 sudo chmod +x /usr/local/bin/bazel


安装依赖
 sudo apt-get install \
    autoconf \
    automake \
    cmake \
    curl \
    libtool \
    make \
    ninja-build \
    patch \
    ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2021/07/16/envoy-debug/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Note"><i class="tag post-item-tag">Note</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2020/05/10/k8s-study/">K8S学习笔记</a></h2><time class="has-text-grey" datetime="2020-05-10T03:00:00.000Z">2020-05-10</time><p class="is-flex-grow-2 mt-2">环境配置Docker File 编写#源镜像
FROM golang:latest
# 容器环境变量添加，会覆盖默认的变量值
ENV GOPROXY=https://goproxy.cn,direct
ENV GO111MODULE=&quot;on&quot;
ENV test=&quot;on&quot;

# 作者
LABEL author=&quot;fanlv&quot;
LABEL email=&quot;fanlvlgh@gmail.com&quot;
#设置工作目录
WORKDIR /go/src/gitee.com/fanlv/GolangDemo/GoTest/docker
# 复制仓库源文件到容器里
COPY . .

# 编译可执行二进制文件(一定要写这些编译参数，指定了可执行程序的运行平台,参考：https://www.jianshu.com/p/4b345a..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2020/05/10/k8s-study/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/17/redis-ha/">Redis 高可用解决方案总结</a></h2><time class="has-text-grey" datetime="2019-08-17T13:06:17.000Z">2019-08-17</time><p class="is-flex-grow-2 mt-2">一、主从复制什么是主从复制我们正常在项目中对redis进行应用，一般都不会是单点的。因为，单点的宕机即不可用，不能保证可用性。另外，单点redis读写指令都会打到同一个服务里面，也会影响性能。在通常的应用中，对redis的读操作远远多于写操作，所以，我们一般会选择“一主多从”的集群策略。


主中的数据有两个副本（replication）即从redis1和从redis2，即使一台服务器宕机其它两台服务也可以继续提供服务。
主中的数据和从上的数据保持实时同步，当主写入数据时通过主从复制机制会复制到两个从服务上。
只有一个主redis，可以有多个从 redis。
主从复制不会阻塞master，在同步数据时，master可以继续处理client请求。

一个可以即是主又是从，如下图：

主从复制过程一般当slav..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/17/redis-ha/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/17/reids-source-code-7/">Redis 源码分析(七) ：skiplist</a></h2><time class="has-text-grey" datetime="2019-08-16T16:44:40.000Z">2019-08-17</time><p class="is-flex-grow-2 mt-2">一、skiplist由来skiplist本质上也是一种查找结构，用于解决算法中的查找问题（Searching），即根据给定的key，快速查到它所在的位置（或者对应的value）。
我们在《Redis内部数据结构详解》系列的第一篇中介绍dict的时候，曾经讨论过：一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。但skiplist却比较特殊，它没法归属到这两大类里面。
这种数据结构是由William Pugh发明的，最早出现于他在1990年发表的论文《Skip Lists: A Probabilistic Alternative to Balanced Trees》。对细节感兴趣的同学可以下载论文原文来阅读。
skiplist，顾名思义，首先它是一个list。实际上，它是在有序链表的基础..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/17/reids-source-code-7/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/12/reids-source-code-6/">Redis 源码分析(六) ：quciklist</a></h2><time class="has-text-grey" datetime="2019-08-11T16:10:29.000Z">2019-08-12</time><p class="is-flex-grow-2 mt-2">一、什么是quicklist由于考虑到链表adlist的附加空间相对太高，prev和next指针就要占去 16 个字节 (64bit系统的指针是8个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。
quicklist是一个3.2版本之后新增的基础数据结构，是redis自定义的一种复杂数据结构，将ziplist和adlist结合到了一个数据结构中。主要是作为list的基础数据结构。在3.2之前，list是根据元素数量的多少采用ziplist或者adlist作为基础数据结构，3.2之后统一改用quicklist，从数据结构的角度来说quicklist结合了两种数据结构的优缺点，复杂但是实用：

链表在插入，删除节点的时间复杂度很低；但是内存利用率低，且由于内存不连续容易产生内存碎片..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/12/reids-source-code-6/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/10/reids-source-code-5/">Redis 源码分析(五) ：ziplist</a></h2><time class="has-text-grey" datetime="2019-08-10T12:50:06.000Z">2019-08-10</time><p class="is-flex-grow-2 mt-2">一、前言ziplist是redis节省内存的典型例子之一，这个数据结构通过特殊的编码方式将数据存储在连续的内存中。在3.2之前是list的基础数据结构之一，在3.2之后被quicklist替代。但是仍然是zset底层实现之一。
二、存储结构压缩表没有数据结构代码定义，完全是通过内存的特殊编码方式实现的一种紧凑存储数据结构。我们可以通过ziplist的初始化函数和操作api来倒推其内存分布。
#define ZIP_END 255

#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))    // 获取ziplist的bytes指针
#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/10/reids-source-code-5/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/10/reids-source-code-4/">Redis 源码分析(四) ：intset</a></h2><time class="has-text-grey" datetime="2019-08-10T08:56:15.000Z">2019-08-10</time><p class="is-flex-grow-2 mt-2">一、什么是intsetintset是Redis内存数据结构之一，用来实现Redis的Set结构（当集合元素不大于设定值并且元素都是整数时，就会用intset作为set的底层数据结构），它的特点有：

元素类型只能为数字。
元素有三种类型：int16_t、int32_t、int64_t。
元素有序，不可重复。
intset和sds一样，内存连续，就像数组一样。

二、数据结构定义typedef struct intset {
    uint32_t encoding;  // 编码类型 int16_t、int32_t、int64_t
    uint32_t length;    // 长度 最大长度:2^32
    int8_t contents[];  // 柔性数组
} intset;


enco..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/10/reids-source-code-4/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/09/reids-source-code-3/">Redis 源码分析(三) ：dict</a></h2><time class="has-text-grey" datetime="2019-08-09T02:58:25.000Z">2019-08-09</time><p class="is-flex-grow-2 mt-2">一、什么是dictdict (dictionary 字典)，通常的存储结构是Key-Value形式的，通过Hash函数对key求Hash值来确定Value的位置，因此也叫Hash表，是一种用来解决算法中查找问题的数据结构，默认的算法复杂度接近O(1)，Redis本身也叫Remote Dictionary Server(远程字典服务器)，其实也就是一个大字典，它的key通常来说是String类型的，但是Value可以是String、Set、ZSet、Hash、List等不同的类型，下面我们看下dict的数据结构定义。
二、Redis Dict数据结构
从上图可以看出与dict相关的关键数据结构有三个，分别是：

dict是Redis中的字典结构，包含两个dictht。
dictht表示一个Hash表。
dic..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/09/reids-source-code-3/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/06/14/reids-source-code-2/">Redis 源码分析(二) ：ADList</a></h2><time class="has-text-grey" datetime="2019-06-14T06:58:00.000Z">2019-06-14</time><p class="is-flex-grow-2 mt-2">概述ADList(A generic doubly linked list)是 redis 自定义的一种双向链表，广泛运用于 redisClients 、 redisServer 、发布订阅、慢查询、监视器等。（注：3.0及以前还会被运用于list结构中，在3.2以后被quicklist取代）。

链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。
链表在Redis 中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis 就会使用链表作为列表键的底层实现。
链表结构是 Redis 中一个常用的结构，它可以存储多个字符串
它是有序的
能够存储2的32次方减一个节点（超过 40..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/06/14/reids-source-code-2/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/06/14/reids-source-code-1/">Redis 源码分析(一) ：sds</a></h2><time class="has-text-grey" datetime="2019-06-14T03:22:24.000Z">2019-06-14</time><p class="is-flex-grow-2 mt-2">什么是sds字符串是Redis中最为常见的数据存储类型，其底层实现是简单动态字符串sds(simple dynamic string)，是可以修改的字符串。
它类似于Java中的ArrayList，它采用预分配冗余空间的方式来减少内存的频繁分配。
数据结构// 3.0及以前
struct sdshdr {
    // 记录buf数组中已使用字节数量
    unsigned int len;
    // 记录buf数组中未使用的字节数量
    unsigned int free;
    // 字节数组，存储字符串
    char buf[];
};

// &amp;gt;=3.2
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned cha..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/06/14/reids-source-code-1/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a><a href="/tags/Backend"><i class="tag post-item-tag">Backend</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/04/04/mysql-index/">MySQL 索引那些事</a></h2><time class="has-text-grey" datetime="2019-04-04T11:56:08.000Z">2019-04-04</time><p class="is-flex-grow-2 mt-2">1. MySQL 常见几种索引类型1.1 普通索引，是最基本的索引，它没有任何限制。它有以下几种创建方式：
（1）直接创建索引

    CREATE INDEX index_name ON table(column(length))

（2）修改表结构的方式添加索引

    ALTER TABLE table_name ADD INDEX index_name ON (column(length))

（3）创建表的时候同时创建索引

    CREATE TABLE `table` (
        `id` int(11) NOT NULL AUTO_INCREMENT ,
        `title` char(255) CHARACTER NOT NULL ,
        `conten..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/04/04/mysql-index/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/10/26/mysql-engine/">MyISAM和InnoDB区别和应用场景</a></h2><time class="has-text-grey" datetime="2018-10-26T08:36:00.000Z">2018-10-26</time><p class="is-flex-grow-2 mt-2">什么是MyISAM 和InnoDB
MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。
InnoDB，是MySQL的数据库引擎之一，为MySQL AB发行binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。

MyISAM：它是基于传统的ISAM类型，ISAM是Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/10/26/mysql-engine/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Consul"><i class="tag post-item-tag">Consul</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/10/12/service-discovery-consul/">服务发现之Consul</a></h2><time class="has-text-grey" datetime="2018-10-12T07:18:18.000Z">2018-10-12</time><p class="is-flex-grow-2 mt-2">consul是一个可以提供服务发现，健康检查，多数据中心，Key/Value存储等功能的分布式服务框架
用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul的方案更”一站式”，内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（比如ZooKeeper等）。使用起来也较为简单。Consul用Golang实现，因此具有天然可移植性(支持Linux、Windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与Docker等轻量级容器可无缝配合。
Consul 的使用场景
docker 实例的注册与配置共享
coreos 实例的注册与配置共享
vitess 集群
SaaS 应用的配置共享
与 confd ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/10/12/service-discovery-consul/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/09/30/idgenerator/">分布式id几种生成方案</a></h2><time class="has-text-grey" datetime="2018-09-30T08:08:10.000Z">2018-09-30</time><p class="is-flex-grow-2 mt-2">一、UUIDUUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2/ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。另外我们也可以在e2fsprogs包中的UUID库找到实现。
UUID的标准形式包含32个16进制数字，以连字号分为五段，形式为8-4-4..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/09/30/idgenerator/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Note"><i class="tag post-item-tag">Note</i></a><a href="/tags/ETCD"><i class="tag post-item-tag">ETCD</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2021/04/11/note/etcd/">《ETCD实战》</a></h2><time class="has-text-grey" datetime="2021-04-11T02:00:35.000Z">2021-04-11</time><p class="is-flex-grow-2 mt-2">背景ectd 常见问题
etcd 基础
etcd 实践
etcd v2 功能
etcd v2 存在的问题

第一，etcd v2 不支持范围查询和分页。分页对于数据较多的场景是必不可少的。在 Kubernetes 中，在集群规模增大后，Pod、Event 等资源可能会出现数千个以上，但是 etcd v2 不支持分页，不支持范围查询，大包等 expensive request 会导致严重的性能乃至雪崩问题。
第二，etcd v2 不支持多 key 事务。在实际转账等业务场景中，往往我们需要在一个事务中同时更新多个 key。
然后是 Watch 机制可靠性问题。Kubernetes 项目严重依赖 etcd Watch 机制，然而 etcd v2 是内存型、不支持保存 key 历史版本的数据库，只在内存中使用滑动..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2021/04/11/note/etcd/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Note"><i class="tag post-item-tag">Note</i></a><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/01/note/mysql-45-lesson/">《MySQL实战45讲》</a></h2><time class="has-text-grey" datetime="2019-08-01T11:56:08.000Z">2019-08-01</time><p class="is-flex-grow-2 mt-2">binlog &amp;amp;&amp;amp; redo log什么是 binlog
binlog 是逻辑日志，记录的是这个语句的原始逻辑/变化，比如“给 ID=2 这一行的 c 字段加 1 ”。 
binlog 是追加写，不会覆盖之前的数据，可以提供完整的数据归档的能力。

什么是 redo log
redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；
redo log 提供 crash-safe 能力。
一般只有4G ，4个文件，循环复写。

binlog 和 redo log 不同点因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/01/note/mysql-45-lesson/">更多</a></section></article></section><aside class="column is-hidden-mobile is-4-tablet is-3-widescreen"><div style="position: sticky; top: 50px;"><main class="aside-card-container tag-widget is-in-tag-page"><h3>标签</h3><section><a href="/tags/DataStructure"><span class="tag post-item-tag" style="margin-bottom: 5px;">DataStructure</span></a><a href="/tags/Calculus"><span class="tag post-item-tag" style="margin-bottom: 5px;">Calculus</span></a><a href="/tags/Golang"><span class="tag post-item-tag" style="margin-bottom: 5px;">Golang</span></a><a href="/tags/HTTP"><span class="tag post-item-tag" style="margin-bottom: 5px;">HTTP</span></a><a href="/tags/Middleware"><span class="tag post-item-tag" style="margin-bottom: 5px;">Middleware</span></a><a href="/tags/Envoy"><span class="tag post-item-tag" style="margin-bottom: 5px;">Envoy</span></a><a href="/tags/Lua"><span class="tag post-item-tag" style="margin-bottom: 5px;">Lua</span></a><a href="/tags/iOS"><span class="tag post-item-tag" style="margin-bottom: 5px;">iOS</span></a><a href="/tags/GRPC"><span class="tag post-item-tag" style="margin-bottom: 5px;">GRPC</span></a><a href="/tags/Note"><span class="tag post-item-tag" style="margin-bottom: 5px;">Note</span></a><a href="/tags/LinearAlgebra"><span class="tag post-item-tag" style="margin-bottom: 5px;">LinearAlgebra</span></a><a href="/tags/MySQL"><span class="tag post-item-tag" style="margin-bottom: 5px;">MySQL</span></a><a href="/tags/Probability"><span class="tag post-item-tag" style="margin-bottom: 5px;">Probability</span></a><a href="/tags/Protobuf"><span class="tag post-item-tag" style="margin-bottom: 5px;">Protobuf</span></a><a href="/tags/Net"><span class="tag post-item-tag" style="margin-bottom: 5px;">Net</span></a><a href="/tags/HTPP"><span class="tag post-item-tag" style="margin-bottom: 5px;">HTPP</span></a><a href="/tags/Distribution"><span class="tag post-item-tag" style="margin-bottom: 5px;">Distribution</span></a><a href="/tags/Redis"><span class="tag post-item-tag" style="margin-bottom: 5px;">Redis</span></a><a href="/tags/IO"><span class="tag post-item-tag" style="margin-bottom: 5px;">IO</span></a><a href="/tags/Consul"><span class="tag post-item-tag" style="margin-bottom: 5px;">Consul</span></a><a href="/tags/Sort"><span class="tag post-item-tag" style="margin-bottom: 5px;">Sort</span></a><a href="/tags/Statistics"><span class="tag post-item-tag" style="margin-bottom: 5px;">Statistics</span></a><a href="/tags/Linux"><span class="tag post-item-tag" style="margin-bottom: 5px;">Linux</span></a><a href="/tags/eng-practices"><span class="tag post-item-tag" style="margin-bottom: 5px;">eng-practices</span></a><a href="/tags/Memory"><span class="tag post-item-tag" style="margin-bottom: 5px;">Memory</span></a><a href="/tags/Backend"><span class="tag post-item-tag" style="margin-bottom: 5px;">Backend</span></a><a href="/tags/GoSourceCode"><span class="tag post-item-tag" style="margin-bottom: 5px;">GoSourceCode</span></a><a href="/tags/Architecture"><span class="tag post-item-tag" style="margin-bottom: 5px;">Architecture</span></a><a href="/tags/ETCD"><span class="tag post-item-tag" style="margin-bottom: 5px;">ETCD</span></a><a href="/tags/Chip"><span class="tag post-item-tag" style="margin-bottom: 5px;">Chip</span></a></section></main></div></aside></div></article><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fanlv"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/fanlvlgh"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Ryo 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"></div><div><span>博学之，审问之，慎思之，明辨之，笃行之</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></body></html>