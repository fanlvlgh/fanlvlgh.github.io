<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>Ryo's blog</title><meta name="description" content="行万里路，读万卷书"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "https://hm.baidu.com/hm.js?" + '2c076421eb9f21a0a143f8ee9c4ab171';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><meta name="referrer" content="no-referrer"><link rel="icon" href="/null"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/widget-post-list.css"><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Ryo's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><span>分类 · Backend</span></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><article class="post-container is-flex is-justify-content-center section container is-max-widescreen pt-4 px-2"><div class="columns is-variable is-1-tablet is-3-desktop-only is-2-widescreen is-full-width"><section class="column"><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://upload-images.jianshu.io/upload_images/12321605-7bac65b41e38666d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2021/12/18/golang-complier-optimize/"><img class="post-cover-img js-img-fadeIn" src="https://upload-images.jianshu.io/upload_images/12321605-7bac65b41e38666d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2021/12/18/golang-complier-optimize/">Golang 编译器优化那些事</a></h2><time class="has-text-grey" datetime="2021-12-18T04:13:14.000Z">2021-12-18</time><p class="is-flex-grow-2 mt-2">



一、背景去年写了一篇 Golang Memory Model 文章。当时在文章里面贴了验证一个线程可见性问题Demo，具体代码如下：
func main() {
    running := true
    go func() {
        println(&quot;start thread1&quot;)
        count := 1
        for running {
            count++
        }
        println(&quot;end thread1: count =&quot;, count) // 这句代码永远执行不到为什么？
    }()
    go func() {
        println(&quot;start thread2&quot;)
        for..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2021/12/18/golang-complier-optimize/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://upload-images.jianshu.io/upload_images/12321605-0feac2eb12658cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2020/06/09/golang-memory-model/"><img class="post-cover-img js-img-fadeIn" src="https://upload-images.jianshu.io/upload_images/12321605-0feac2eb12658cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2020/06/09/golang-memory-model/">Golang Memory Model</a></h2><time class="has-text-grey" datetime="2020-06-08T17:32:00.000Z">2020-06-09</time><p class="is-flex-grow-2 mt-2">

一、背景1.1 一个 Code Review 引发的思考一个同学在 Golang 项目里面用 Double Check（不清楚的同学可以去百度搜下，Java中比较常见）的方式实现了一个单例。具体实现如下：
var (
    lock     sync.Mutex
    instance *UserInfo
)

func getInstance() (*UserInfo, error) {
    if instance == nil {
        //---Lock
        lock.Lock()
        defer lock.Unlock()
        if instance == nil {
            instance = &amp;amp;UserInfo{..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2020/06/09/golang-memory-model/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/eng-practices"><i class="tag post-item-tag">eng-practices</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/02/26/dts/">数据传输系统落地和思考</a></h2><time class="has-text-grey" datetime="2022-02-26T14:00:00.000Z">2022-02-26</time><p class="is-flex-grow-2 mt-2">一、背景我们的产品需要支持 Multi-Geo 功能。 
什么是Multi-Geo？简单的说就是：“将一个租户下不同用户/设备/组织等数据，分散存储在不同的地理位置的能力”，在同一个租下管理员可以配置任意用户的数据驻留地（Preferred Data Location简称PDL）。
该功能主要是解决跨国企业，数据合规存放的问题。支持同一个企业下，不用国家的用户，数据存放在不同的国家的机房。
Multi-Geo的功能涉及到几点核心能力。

数据的路由能力。比如，我们服务在CN收到一个User数据查询需求，首先我们要知道这个User是归属于CN还是i18n（国外）的Unit，然后再把请求转发给相应的Unit的服务。
数据的定位能力，管理员更新用户的PDL时候，我们需要把用户所有的数据（存量和增量）找出来，然后发..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/02/26/dts/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2021/08/01/golang-stack/">深入理解 Golang Stack</a></h2><time class="has-text-grey" datetime="2021-07-31T17:50:20.000Z">2021-08-01</time><p class="is-flex-grow-2 mt-2">





基础知识Linux 进程地址空间布局我们知道CPU有实模式和保护模式，系统刚刚启动的时候是运行在实模式下，然后经过一系列初始化工作以后，Linux会把CPU的实模式改为保护模式（具体就是修改CPU的CR0寄存器相关标记位），在保护模式下，CPU访问的地址都是虚拟地址(逻辑地址)。Linux 为了每个进程维护了一个单独的虚拟地址空间，虚拟地址空间又分为“用户空间”和“内核空间”。 虚拟地址空间更多相关可以看Linux内核虚拟地址空间这篇文章。



Golang 栈内存在虚拟地址空间哪个区域Golang 的内存管理是用的 TCMalloc（Thread-Caching Malloc）算法, 简单点说就是 Golang 是使用 mmap 函数去操作系统申请一大块内存，然后把内存按照 8Byte~32..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2021/08/01/golang-stack/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2021/02/11/mysql-insert-lock/">MySQL Insert 死锁问题研究</a></h2><time class="has-text-grey" datetime="2021-02-10T17:36:27.000Z">2021-02-11</time><p class="is-flex-grow-2 mt-2">背景不想看废话的，建议直接去最后看死锁的本质原因。
问题背景线上一个很简单结构的表，报insert死锁，这个表基本上只有insert操作，所以引出一个问题insert 和insert之间为什么会死锁？
顺便说下我们线上库的隔离级别都是RC，日志格式是ROW，我下面所有测试都是在RC下。
*** (1) TRANSACTION:
TRANSACTION 2404187192, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 8 lock struct(s), heap size 1136, 2 row lock(s)
MySQL thread id 118913019, OS thread handle 140411115681..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2021/02/11/mysql-insert-lock/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/10/08/sync-mutex/">Go源码——Sync.Mutex</a></h2><time class="has-text-grey" datetime="2022-10-08T02:26:22.000Z">2022-10-08</time><p class="is-flex-grow-2 mt-2">一、背景sync.Mutex是我们常用到的一把锁。网上讲这个锁的文章也比较多，这里面主要是为了简单做个自我总结。
Sync.Mutex 慢路径底层依赖的是runtime_SemacquireMutex和runtime_Semrelease，对这个不了解可以先去看下 runtime.semaphore 。
二、Sync.Mutex 源码2.1 发展历史sync.Mutex第一版 代码 是2008年的时候 @rsc 提交的。最早的实现比较简单，是通过简单的CAS加信号量的方式来实现的。信号量具体可以参考 runtime-sema 这篇文章。
@dvyukov 2011年的时候，提交了第一次优化了 sync: improve Mutex to allow successive acquisitions，这一版中加..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/10/08/sync-mutex/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/10/06/runtime-sema/">Go源码——runtime.semaphore</a></h2><time class="has-text-grey" datetime="2022-10-06T12:08:29.000Z">2022-10-06</time><p class="is-flex-grow-2 mt-2">一、背景sync.Mutex里面用了runtime_SemacquireMutex和runtime_Semrelease，所以看下这个runtime的信号量是如何实现的。
二、基础知识2.1 信号量信号量（英语：semaphore）又称为信号标，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；当线程完成一次对semaphore对象的释放（release）时，计数值加一。当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态。semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态。
信号量的概念是由荷兰计算机科学家艾兹赫..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/10/06/runtime-sema/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a><a href="/tags/GoSourceCode"><i class="tag post-item-tag">GoSourceCode</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/10/05/runtime-mutex/">Go源码——runtime.mutex</a></h2><time class="has-text-grey" datetime="2022-10-05T02:45:14.000Z">2022-10-05</time><p class="is-flex-grow-2 mt-2">一、背景在Go的runtime包中封装了一个 mutux ，这个mutex被runtime包中大量组件使用，比如 channel、netpoll、Runtime 调度的 checkTimers 等等。
sync.Mutex和runtime.mutext区别：简单说就是sync.Mutex是上层的锁，Lock拿锁失败会造成goroutine阻塞（会调用gopark）。runtime.mutex 是给 runtime使用的锁，Lock拿锁失败，会造成m阻塞（线程阻塞，底层调用的futex）。
二、基础知识2.1 MutexMutex 全称是Mutual Exclusion ，俗称互斥体或者互斥锁。是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/10/05/runtime-mutex/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a><a href="/tags/GoSourceCode"><i class="tag post-item-tag">GoSourceCode</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/10/01/sync-map/">Go源码——Sync.Map的前生今世</a></h2><time class="has-text-grey" datetime="2022-09-30T16:22:26.000Z">2022-10-01</time><p class="is-flex-grow-2 mt-2">一、背景前段时间有个朋友来问我Go的Sync.Map性能怎么样，一般什么场景推荐使用。一句话介绍的话，就是Sync.Map底层有两个map，一个是read，一个是dirty，读写read中数据不需要加锁，读写dirty不用需要加锁，适用于读多写少的场景。
碎碎念其实2020年的时候Go源码里面一些比较常用的包都大致看了一遍，当时跟槊槊、大飞哥、周老板空闲时间天天讨论各种技术细节，包括但不仅限于操作系统、MySQL、Redis、分布式、Go、项目架构方法论等。很多时候观点不合还会争的面红耳赤，最后还会上升到人生攻击，你不服我，我也不服你（实际上互有对错，我也被打过几次脸）。因为有的东西，网上有很多错误的资料，导致我养成了一个习惯，找资料的时候我一般都是去看一些权威的技术书或者直接去看开源组件源码，能用代码说的..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/10/01/sync-map/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/09/12/unsafe-pointer/">GO非类型安全指针-Unsafe.Pointer</a></h2><time class="has-text-grey" datetime="2022-09-12T09:11:12.000Z">2022-09-12</time><p class="is-flex-grow-2 mt-2">一、背景朋友发了一段测试代码里面不正确的使用了atomic.StorePointer，导致GC的时候程序Panic了。
var current int64
atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&amp;amp;current)), unsafe.Pointer(&amp;amp;latest))

为什么会Panic这里先按下不表。之前对 unsafe.Pointer 用的并不多，也没有系统了解过。所以就想系统看下。看了下 unsafe.Pointer 官方文档还挺详细的，可能只之前使用出错的人太多了，所以 rsc 单独提了一个 CR 来说明unsafe.Pointer的用法。
二、unsafe.Pointerunsafe.Pointer表示指向任意类型..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/09/12/unsafe-pointer/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/09/03/go-custom-import-domain/">Go 自定义引用包的域名</a></h2><time class="has-text-grey" datetime="2022-09-03T15:58:00.000Z">2022-09-03</time><p class="is-flex-grow-2 mt-2">一、 背景最近在看 Go源码的时候，发下部分库最早是在 x-pkg 里面的，经过一段时间迭代才进了runtime包里面。
 x-pkg 里面介绍了用途和源码地址。
 golang.org/x 文档
我发现 x-pkg 的源码地址都在 https://go.googlesource.com， 但是我们项目里面导入某个x-pkg库的路径确是
import &quot;golang.org/x/sync/semaphore&quot;

比较好奇，这import的别名是在哪里做的，感觉是个挺冷门的知识，于是搜了下相关资料。
二、实现步骤找到了官网相关资料： hdr-Remote_import_paths
简单说就是在你的网址里面加入如下信息。
&amp;lt;meta name=&quot;go-import&quot; content=&quot;example.or..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/09/03/go-custom-import-domain/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/06/02/golang-pprof-mem/">一次线上内存使用率异常问题排查</a></h2><time class="has-text-grey" datetime="2022-06-02T01:00:00.000Z">2022-06-02</time><p class="is-flex-grow-2 mt-2">一、背景朋友的一个服务，某个集群内存的RSS使用率一直在80%左右，他用的是8核16G, 双机房一共206个实例。

但是在pprof里面查的堆内存才使用了6.3G左右，程序里面主要用了6G的LocalCache所以heap用了6.3G是符合预期的。

朋友让我帮忙看下，额外的内存到底是被啥占用了。
二、基础知识2.1 TCMalloc 算法Thread-Caching Malloc 是Google开发的内存分配算法库，最开始它是作为Google的一个性能工具库perftools的一部分。
TCMalloc是用来替代传统的malloc内存分配函数。它有减少内存碎片，适用于多核，更好的并行性支持等特性。
2.2 mmap 函数mmap它的主要功能是将一个虚拟内存区域与一个磁盘上的文件关联起来，以初始化这个虚拟..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/06/02/golang-pprof-mem/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/05/25/mysql-insert-auto-incre/">MySQL 自增列 Duplicate Error 问题分析</a></h2><time class="has-text-grey" datetime="2022-05-25T04:30:56.000Z">2022-05-25</time><p class="is-flex-grow-2 mt-2">一、背景最近我们在做线上的数据迁移测试（可以理解就是把A数据中心的数据迁移到B数据中心，A和B数据中心的MySQL是同构的，迁移过程中，A、B的MySQL都有正常的业务数据写入，具体背景可以看 数据传输系统落地和思考 这篇文章）。每次我们触发迁移的时候，就有业务方反馈他们写入数据的时候就会有Error 1062: Duplicate entry 'xxx' for key 'PRIMARY'这样的错误。业务方同学还反馈他们写数据的时候并没有指定ID，所以他们对这样的报错比较困惑，具体他们的数据写入的伪代码如下：
type Data struct {
    ID           int64     `gorm:&quot;primaryKey;column:id&quot;`
    PageID       string..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/05/25/mysql-insert-auto-incre/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/05/20/go-for-range/">Go for-range 的奇技淫巧</a></h2><time class="has-text-grey" datetime="2022-05-20T01:01:26.000Z">2022-05-20</time><p class="is-flex-grow-2 mt-2">背景朋友发了两个代码片段给我看，让我猜输出的内容是啥。具体代码如下：
// Demo1 
// 1. 这个循环是否能停下来？
// 2. 如果能停下来，打印的 arr 内容是什么？
arr := []int{1, 2, 3}
for _, v := range arr {
    arr = append(arr, v)
}

fmt.Println(arr)


// Demo2
// 1. idx 和 value 输出多少？
// 2. 输出几行？
str := &quot;你好&quot;
for idx, v := range str {
    fmt.Printf(&quot;idx = %d , value = %c\n&quot;, idx, v)
}

不卖关子，先说下第一个Demo输出的是：
[1 2 3 1 2 3]

第二..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/05/20/go-for-range/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Note"><i class="tag post-item-tag">Note</i></a><a href="/tags/Distribution"><i class="tag post-item-tag">Distribution</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/03/08/raft-introduction/">《Raft-分布式共识算法》</a></h2><time class="has-text-grey" datetime="2022-03-08T15:00:00.000Z">2022-03-08</time><p class="is-flex-grow-2 mt-2">一、背景在分布式系统中，一致性算法至关重要。在所有一致性算法中，Paxos最负盛名，它由莱斯利·兰伯特（Leslie Lamport）于1990年提出，是一种基于消息传递的一致性算法，被认为是类似算法中最有效的。
Paxos算法虽然很有效，但复杂的原理使它实现起来非常困难，截止目前，实现Paxos算法的开源软件很少，比较出名的有Chubby、LibPaxos。此外，Zookeeper采用的 ZAB（Zookeeper Atomic Broadcast）协议也是基于Paxos算法实现的，不过ZAB对Paxos进行了很多改进与优化，两者的设计目标也存在差异——ZAB协议主要用于构建一个高可用的分布式数据主备系统，而Paxos 算法则是用于构建一个分布式的一致性状态机系统。
由于Paxos算法过于复杂、实现困难，..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/03/08/raft-introduction/">更多</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://upload-images.jianshu.io/upload_images/12321605-5a4f15ef8cd7c7b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2021/11/28/mysql-time/"><img class="post-cover-img js-img-fadeIn" src="https://upload-images.jianshu.io/upload_images/12321605-5a4f15ef8cd7c7b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2021/11/28/mysql-time/">MySQL DateTime和Timestamp时区问题</a></h2><time class="has-text-grey" datetime="2021-11-27T17:00:00.000Z">2021-11-28</time><p class="is-flex-grow-2 mt-2">


一、背景最近负责一个数据传输的项目，其中一个需求就是能把一个DB里面的数据拉出来 ，然后回放到另外一个同构的DB。两个DB的服务不在一个时区（其实这不是重点），可能配置不同。之前有过类似的项目，当时是基建的同事负责做数据同步，同步过去以后DateTime、Timestamp字段的时区信息都丢了。老板让我调研下问题根因，不要踩之前的坑。
最早的时候看了下同事写的当时MySQL时区信息丢失的问题总结文档，文档里面当时把DateTime和Timestamp两个时区问题混为一起了，也没分析本质原因，导致我当时没看太明白，然后的武断的认为，之所以时区丢失了，是因为基础组件同步DateTime和Timestamp的时候同步的是字符串，比如2021-11-27 10:49:35.857969这种信息，我们传输的时候..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2021/11/28/mysql-time/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Envoy"><i class="tag post-item-tag">Envoy</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2021/07/16/envoy-debug/">Envoy 编译调试</a></h2><time class="has-text-grey" datetime="2021-07-16T12:09:00.000Z">2021-07-16</time><p class="is-flex-grow-2 mt-2">Debian9 上编译调试主要参考Envoy官方的Bazel编译文档

下载bazelisk-linux-amd64
 sudo wget -O /usr/local/bin/bazel https://github.com/bazelbuild/bazelisk/releases/latest/download/bazelisk-linux-amd64
 sudo chmod +x /usr/local/bin/bazel


安装依赖
 sudo apt-get install \
    autoconf \
    automake \
    cmake \
    curl \
    libtool \
    make \
    ninja-build \
    patch \
    ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2021/07/16/envoy-debug/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Note"><i class="tag post-item-tag">Note</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2021/02/10/reids-action/">《Redis核心技术与实战》</a></h2><time class="has-text-grey" datetime="2021-02-10T10:32:31.000Z">2021-02-10</time><p class="is-flex-grow-2 mt-2">数据结构Redis数据结构简单来说，底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：

全局哈希表
因为这个哈希表保存了所有的键值对，所以，我也把它称为全局哈希表。哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。
渐进式 rehash简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entr..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2021/02/10/reids-action/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2020/06/06/golang-rmmutex/">Golang RWMutext 代码走读</a></h2><time class="has-text-grey" datetime="2020-06-06T14:20:56.000Z">2020-06-06</time><p class="is-flex-grow-2 mt-2">type RWMutex struct {
   w           Mutex  // held if there are pending writers
   writerSem   uint32 // 写的信号量
   readerSem   uint32 // 读的信号量
   readerCount int32  // 等待写的个数
   readerWait  int32  // 等待读的个数
}


// 加“读锁”
// 对readerCount + 1 。
// 然后看 readerCount是不是小于0
// 小于0表示 正在加写锁，然后阻塞到rw.readerSem 这个信号上。
func (rw *RWMutex) RLock() {
   if atomic.AddInt32(..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2020/06/06/golang-rmmutex/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/17/redis-ha/">Redis 高可用解决方案总结</a></h2><time class="has-text-grey" datetime="2019-08-17T13:06:17.000Z">2019-08-17</time><p class="is-flex-grow-2 mt-2">一、主从复制什么是主从复制我们正常在项目中对redis进行应用，一般都不会是单点的。因为，单点的宕机即不可用，不能保证可用性。另外，单点redis读写指令都会打到同一个服务里面，也会影响性能。在通常的应用中，对redis的读操作远远多于写操作，所以，我们一般会选择“一主多从”的集群策略。


主中的数据有两个副本（replication）即从redis1和从redis2，即使一台服务器宕机其它两台服务也可以继续提供服务。
主中的数据和从上的数据保持实时同步，当主写入数据时通过主从复制机制会复制到两个从服务上。
只有一个主redis，可以有多个从 redis。
主从复制不会阻塞master，在同步数据时，master可以继续处理client请求。

一个可以即是主又是从，如下图：

主从复制过程一般当slav..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/17/redis-ha/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/17/reids-source-code-7/">Redis 源码分析(七) ：skiplist</a></h2><time class="has-text-grey" datetime="2019-08-16T16:44:40.000Z">2019-08-17</time><p class="is-flex-grow-2 mt-2">一、skiplist由来skiplist本质上也是一种查找结构，用于解决算法中的查找问题（Searching），即根据给定的key，快速查到它所在的位置（或者对应的value）。
我们在《Redis内部数据结构详解》系列的第一篇中介绍dict的时候，曾经讨论过：一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。但skiplist却比较特殊，它没法归属到这两大类里面。
这种数据结构是由William Pugh发明的，最早出现于他在1990年发表的论文《Skip Lists: A Probabilistic Alternative to Balanced Trees》。对细节感兴趣的同学可以下载论文原文来阅读。
skiplist，顾名思义，首先它是一个list。实际上，它是在有序链表的基础..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/17/reids-source-code-7/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/12/reids-source-code-6/">Redis 源码分析(六) ：quciklist</a></h2><time class="has-text-grey" datetime="2019-08-11T16:10:29.000Z">2019-08-12</time><p class="is-flex-grow-2 mt-2">一、什么是quicklist由于考虑到链表adlist的附加空间相对太高，prev和next指针就要占去 16 个字节 (64bit系统的指针是8个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。
quicklist是一个3.2版本之后新增的基础数据结构，是redis自定义的一种复杂数据结构，将ziplist和adlist结合到了一个数据结构中。主要是作为list的基础数据结构。在3.2之前，list是根据元素数量的多少采用ziplist或者adlist作为基础数据结构，3.2之后统一改用quicklist，从数据结构的角度来说quicklist结合了两种数据结构的优缺点，复杂但是实用：

链表在插入，删除节点的时间复杂度很低；但是内存利用率低，且由于内存不连续容易产生内存碎片..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/12/reids-source-code-6/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/10/reids-source-code-5/">Redis 源码分析(五) ：ziplist</a></h2><time class="has-text-grey" datetime="2019-08-10T12:50:06.000Z">2019-08-10</time><p class="is-flex-grow-2 mt-2">一、前言ziplist是redis节省内存的典型例子之一，这个数据结构通过特殊的编码方式将数据存储在连续的内存中。在3.2之前是list的基础数据结构之一，在3.2之后被quicklist替代。但是仍然是zset底层实现之一。
二、存储结构压缩表没有数据结构代码定义，完全是通过内存的特殊编码方式实现的一种紧凑存储数据结构。我们可以通过ziplist的初始化函数和操作api来倒推其内存分布。
#define ZIP_END 255

#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))    // 获取ziplist的bytes指针
#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/10/reids-source-code-5/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/10/reids-source-code-4/">Redis 源码分析(四) ：intset</a></h2><time class="has-text-grey" datetime="2019-08-10T08:56:15.000Z">2019-08-10</time><p class="is-flex-grow-2 mt-2">一、什么是intsetintset是Redis内存数据结构之一，用来实现Redis的Set结构（当集合元素不大于设定值并且元素都是整数时，就会用intset作为set的底层数据结构），它的特点有：

元素类型只能为数字。
元素有三种类型：int16_t、int32_t、int64_t。
元素有序，不可重复。
intset和sds一样，内存连续，就像数组一样。

二、数据结构定义typedef struct intset {
    uint32_t encoding;  // 编码类型 int16_t、int32_t、int64_t
    uint32_t length;    // 长度 最大长度:2^32
    int8_t contents[];  // 柔性数组
} intset;


enco..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/10/reids-source-code-4/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/09/reids-source-code-3/">Redis 源码分析(三) ：dict</a></h2><time class="has-text-grey" datetime="2019-08-09T02:58:25.000Z">2019-08-09</time><p class="is-flex-grow-2 mt-2">一、什么是dictdict (dictionary 字典)，通常的存储结构是Key-Value形式的，通过Hash函数对key求Hash值来确定Value的位置，因此也叫Hash表，是一种用来解决算法中查找问题的数据结构，默认的算法复杂度接近O(1)，Redis本身也叫Remote Dictionary Server(远程字典服务器)，其实也就是一个大字典，它的key通常来说是String类型的，但是Value可以是String、Set、ZSet、Hash、List等不同的类型，下面我们看下dict的数据结构定义。
二、Redis Dict数据结构
从上图可以看出与dict相关的关键数据结构有三个，分别是：

dict是Redis中的字典结构，包含两个dictht。
dictht表示一个Hash表。
dic..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/09/reids-source-code-3/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/06/14/reids-source-code-2/">Redis 源码分析(二) ：ADList</a></h2><time class="has-text-grey" datetime="2019-06-14T06:58:00.000Z">2019-06-14</time><p class="is-flex-grow-2 mt-2">概述ADList(A generic doubly linked list)是 redis 自定义的一种双向链表，广泛运用于 redisClients 、 redisServer 、发布订阅、慢查询、监视器等。（注：3.0及以前还会被运用于list结构中，在3.2以后被quicklist取代）。

链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。
链表在Redis 中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis 就会使用链表作为列表键的底层实现。
链表结构是 Redis 中一个常用的结构，它可以存储多个字符串
它是有序的
能够存储2的32次方减一个节点（超过 40..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/06/14/reids-source-code-2/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Redis"><i class="tag post-item-tag">Redis</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/06/14/reids-source-code-1/">Redis 源码分析(一) ：sds</a></h2><time class="has-text-grey" datetime="2019-06-14T03:22:24.000Z">2019-06-14</time><p class="is-flex-grow-2 mt-2">什么是sds字符串是Redis中最为常见的数据存储类型，其底层实现是简单动态字符串sds(simple dynamic string)，是可以修改的字符串。
它类似于Java中的ArrayList，它采用预分配冗余空间的方式来减少内存的频繁分配。
数据结构// 3.0及以前
struct sdshdr {
    // 记录buf数组中已使用字节数量
    unsigned int len;
    // 记录buf数组中未使用的字节数量
    unsigned int free;
    // 字节数组，存储字符串
    char buf[];
};

// &amp;gt;=3.2
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned cha..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/06/14/reids-source-code-1/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/10/26/mysql-engine/">MyISAM和InnoDB区别和应用场景</a></h2><time class="has-text-grey" datetime="2018-10-26T08:36:00.000Z">2018-10-26</time><p class="is-flex-grow-2 mt-2">什么是MyISAM 和InnoDB
MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。
InnoDB，是MySQL的数据库引擎之一，为MySQL AB发行binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。

MyISAM：它是基于传统的ISAM类型，ISAM是Indexed Sequential Access Method (有索引的顺序访问方法) 的缩写，它是存储记录和文件的标准方法。不是事务安全的，而且..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/10/26/mysql-engine/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/10/16/data-struct-alignment/">Golang 内存对齐问题</a></h2><time class="has-text-grey" datetime="2018-10-16T12:52:07.000Z">2018-10-16</time><p class="is-flex-grow-2 mt-2">什么是内存对齐？CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为memory access granularity（粒度）。

假设CPU访问粒度是4，也就是一次性可以读取内存中的四个字节内容；当我们不采用内存对齐策略，如果需要访问A中的b元素，CPU需要先取出0-3四个字节的内容，发现没有读取完，还需要再次读取，一共需要进行两次访问内存的操作；而有了内存对齐，参考左图，可一次性取出4-7四个字节的元素也即是b，这样就只需要进行一次访问内存的操作。所以操作系统这样做的原因也就是所谓的拿空间换时间，提高效率。
为什么要内存对齐？会了关于结构体内存大小的计算，可是为什么系统要对于结构体数据进行内存对齐呢，很明显所占用的空间大小要更多。原..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/10/16/data-struct-alignment/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Consul"><i class="tag post-item-tag">Consul</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/10/12/service-discovery-consul/">服务发现之Consul</a></h2><time class="has-text-grey" datetime="2018-10-12T07:18:18.000Z">2018-10-12</time><p class="is-flex-grow-2 mt-2">consul是一个可以提供服务发现，健康检查，多数据中心，Key/Value存储等功能的分布式服务框架
用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul的方案更”一站式”，内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（比如ZooKeeper等）。使用起来也较为简单。Consul用Golang实现，因此具有天然可移植性(支持Linux、Windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与Docker等轻量级容器可无缝配合。
Consul 的使用场景
docker 实例的注册与配置共享
coreos 实例的注册与配置共享
vitess 集群
SaaS 应用的配置共享
与 confd ..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/10/12/service-discovery-consul/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/09/30/idgenerator/">分布式id几种生成方案</a></h2><time class="has-text-grey" datetime="2018-09-30T08:08:10.000Z">2018-09-30</time><p class="is-flex-grow-2 mt-2">一、UUIDUUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2/ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。另外我们也可以在e2fsprogs包中的UUID库找到实现。
UUID的标准形式包含32个16进制数字，以连字号分为五段，形式为8-4-4..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/09/30/idgenerator/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a><a href="/tags/Lua"><i class="tag post-item-tag">Lua</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/08/30/go-lua-js/">Go 执行Lua脚本和JS脚本测试</a></h2><time class="has-text-grey" datetime="2018-08-30T09:08:12.000Z">2018-08-30</time><p class="is-flex-grow-2 mt-2">最近有个需求需要在Go项目里面执行动态脚本，github上有好几个lua执行解释器，但是有很多要不就很久没维护了，要不就没有什么文档，经过几个对比我最后用的是 https://github.com/yuin/gopher-lua。JS解析器用的github.com/robertkrimen/otto。
具体测试代码如下，给有需求的朋友参考。
github地址
package main

import (
    &quot;fmt&quot;
    &quot;github.com/robertkrimen/otto&quot;
    &quot;github.com/yuin/gluamapper&quot;
    &quot;github.com/yuin/gopher-lua&quot;
    &quot;time&quot;
)

//function add(a, b)
//return..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/08/30/go-lua-js/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Protobuf"><i class="tag post-item-tag">Protobuf</i></a><a href="/tags/Net"><i class="tag post-item-tag">Net</i></a><a href="/tags/HTPP"><i class="tag post-item-tag">HTPP</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/08/19/protobuf-on-http/">测试Protobuf在Http传输测试</a></h2><time class="has-text-grey" datetime="2018-08-19T10:08:37.000Z">2018-08-19</time><p class="is-flex-grow-2 mt-2">Demo：https://github.com/fanlv/ProtobufOnHttpGo
一、编写Proto文件syntax = &quot;proto3&quot;;

// 生成go代码
//protoc --go_out=. user.proto

// 生成oc代码
//protoc --objc_out=. user.proto

package user;


message LoginRequest {
  string username = 1;
  string password = 2;
}

message BaseResponse{
  int64 code = 1;
  string msg = 2;
}


message User{
    string uid = 1;
    string..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/08/19/protobuf-on-http/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/IO"><i class="tag post-item-tag">IO</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/07/15/server-io-model/">高并发服务器IO模型</a></h2><time class="has-text-grey" datetime="2018-07-15T12:20:04.000Z">2018-07-15</time><p class="is-flex-grow-2 mt-2">服务端IO模型总结 草稿
网络框架视角零、Nginx
一、Netty（主从Reactor）MainReactor负责客户端的连接请求，并将请求转交给SubReactor
SubReactor负责相应通道的IO读写请求
非IO请求（具体逻辑处理）的任务则会直接写入队列，等待worker threads进行处理



二、GRPC-GO （Goroutine Per Connection）net.Listen -&amp;gt; Serve() -&amp;gt; lis.Accept() net库的accept 
-&amp;gt; 一个连接开个一个goroutine -&amp;gt; s.handleRawConn(rawConn) 
-&amp;gt; newHTTP2Transport(conn, authInfo) -&amp;gt;  newH..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/07/15/server-io-model/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Golang"><i class="tag post-item-tag">Golang</i></a><a href="/tags/HTTP"><i class="tag post-item-tag">HTTP</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/07/12/csrf/">跨域请求的几种解决方案</a></h2><time class="has-text-grey" datetime="2018-07-12T08:24:18.000Z">2018-07-12</time><p class="is-flex-grow-2 mt-2">需求背景最近做的Apigate优化，前端的同学要求能在配置后台页面上加上一键测试接口的功能，但是由于浏览器的同源策略防止跨域攻击，所以前端的页面默认是不能请求其他域名的接口。
方案一 Nginx配置代理location /proxy {
   if ($arg_url) {
      proxy_pass $arg_url?;
    }
 }

最开始为了简单就配置了一个简单的代理，通过url传入想要访问的接口例如：
http://nginxserver/proxy?url=http://10.23.39.140:8080/app/list

这样前端需要什么测试什么接口只需要通过url传过来，Nginx会方向代理到对应的url上返回结果。
但是这个方法有个问题，url中的地址支持IP访问，不支持域名的..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/07/12/csrf/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HTTP"><i class="tag post-item-tag">HTTP</i></a><a href="/tags/Net"><i class="tag post-item-tag">Net</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/06/08/simple-http/">深入浅出HTTP</a></h2><time class="has-text-grey" datetime="2018-06-08T08:19:47.000Z">2018-06-08</time><p class="is-flex-grow-2 mt-2">深入浅出HTTP一、什么是Http和TCP
HTTP（HyperText Transfer Protocol)超文本传输协议，是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。


TCP（T..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/06/08/simple-http/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HTTP"><i class="tag post-item-tag">HTTP</i></a><a href="/tags/Protobuf"><i class="tag post-item-tag">Protobuf</i></a><a href="/tags/Net"><i class="tag post-item-tag">Net</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2018/06/03/protobuf-on-http-study/">Protobuf On HTTP 技术预研 （附代码）</a></h2><time class="has-text-grey" datetime="2018-06-03T13:01:29.000Z">2018-06-03</time><p class="is-flex-grow-2 mt-2">Protobuf 技术预研Demo地址：https://github.com/fanlv/ProtobufOnHttp
Demo地址：https://github.com/fanlv/ProtobufOnHttpGo
一、背景现在客户端与服务器通讯主要通过Json来做数据交互，本次调研主要比较Protobuf项目中使用的优缺点，和可行性。
二、Protobuf说明2.1 什么是ProtobufProtocolBuffer(以下简称PB)是google 的一种数据交换的格式，它独立于语言，独立于平台。大部分IM通讯协议都是使用PB来传输。具体代表性的有支付宝、微信等App。
说白了，PB就是一种序列化协议，我们开发中想在什么场景中使用Protobuf做为数据交换的序列化协议，取决于自己的业务。
2.2 Pro..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2018/06/03/protobuf-on-http-study/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Note"><i class="tag post-item-tag">Note</i></a><a href="/tags/ETCD"><i class="tag post-item-tag">ETCD</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2021/04/11/note/etcd/">《ETCD实战》</a></h2><time class="has-text-grey" datetime="2021-04-11T02:00:35.000Z">2021-04-11</time><p class="is-flex-grow-2 mt-2">背景ectd 常见问题
etcd 基础
etcd 实践
etcd v2 功能
etcd v2 存在的问题

第一，etcd v2 不支持范围查询和分页。分页对于数据较多的场景是必不可少的。在 Kubernetes 中，在集群规模增大后，Pod、Event 等资源可能会出现数千个以上，但是 etcd v2 不支持分页，不支持范围查询，大包等 expensive request 会导致严重的性能乃至雪崩问题。
第二，etcd v2 不支持多 key 事务。在实际转账等业务场景中，往往我们需要在一个事务中同时更新多个 key。
然后是 Watch 机制可靠性问题。Kubernetes 项目严重依赖 etcd Watch 机制，然而 etcd v2 是内存型、不支持保存 key 历史版本的数据库，只在内存中使用滑动..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2021/04/11/note/etcd/">更多</a></section></article><article class="post-item-card"><section class="content post-card-content p-4 pb-5"><header><a href="/tags/Middleware"><i class="tag post-item-tag">Middleware</i></a><a href="/tags/Note"><i class="tag post-item-tag">Note</i></a><a href="/tags/MySQL"><i class="tag post-item-tag">MySQL</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2019/08/01/note/mysql-45-lesson/">《MySQL实战45讲》</a></h2><time class="has-text-grey" datetime="2019-08-01T11:56:08.000Z">2019-08-01</time><p class="is-flex-grow-2 mt-2">binlog &amp;amp;&amp;amp; redo log什么是 binlog
binlog 是逻辑日志，记录的是这个语句的原始逻辑/变化，比如“给 ID=2 这一行的 c 字段加 1 ”。 
binlog 是追加写，不会覆盖之前的数据，可以提供完整的数据归档的能力。

什么是 redo log
redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；
redo log 提供 crash-safe 能力。
一般只有4G ，4个文件，循环复写。

binlog 和 redo log 不同点因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2019/08/01/note/mysql-45-lesson/">更多</a></section></article></section><aside class="column is-hidden-mobile is-4-tablet is-3-widescreen"><div style="position: sticky; top: 50px;"><main class="aside-card-container categories-widget category-page"><h3>分类</h3><section><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Architecture/">Architecture</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Arithmetic/">Arithmetic</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Backend/">Backend</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/">Frontend</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Literature/">Literature</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Maths/">Maths</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Net/">Net</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/System/">System</a><span class="category-list-count">9</span></li></ul></section></main></div></aside></div></article><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/fanlv"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/fanlvlgh"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Ryo 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"></div><div><span>博学之，审问之，慎思之，明辨之，笃行之</span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></body></html>